#+BIND: org-latex-listings-options (("style" "SuperCollider-IDE") ("basicstyle" "\\ttfamily\\small") ("captionpos" "b") ("tabsize" "3"))

#+OPTIONS: ':t *:t -:t ::t <:t H:4 \n:nil ^:t arch:headline author:t
#+OPTIONS: c:nil creator:comment d:(not "LOGBOOK") date:t e:t
#+OPTIONS: email:nil f:t inline:t num:t p:nil pri:nil prop:nil stat:t
#+OPTIONS: tags:t tasks:t tex:t timestamp:t toc:t todo:t |:t
#+TITLE: Chucklib-Livecode Manual
#+AUTHOR: H. James Harkins
#+EMAIL: dlm@hjh-e431
#+DESCRIPTION:
#+KEYWORDS:
#+LANGUAGE: en
#+SELECT_TAGS: export
#+EXCLUDE_TAGS: noexport
#+CREATOR: Emacs 24.3.1 (Org mode 8.3beta)

#+LATEX_CLASS: article
#+LATEX_CLASS_OPTIONS:
#+LATEX_HEADER:
#+LATEX_HEADER_EXTRA:
#+DATE: \today

#+LATEX_HEADER: \setcounter{tocdepth}{2}
#+LATEX_HEADER: \setcounter{secnumdepth}{4}

#+LATEX_HEADER: \usepackage{fontspec}
#+LATEX_HEADER: \setmainfont[Ligatures={Common,TeX}]{CharisSIL}
#+LATEX_HEADER: \setmonofont{Inconsolata}

#+LATEX_HEADER: \usepackage{caption}
#+LATEX_HEADER: \captionsetup[figure]{font={it,footnotesize},labelfont={it,footnotesize},singlelinecheck=false}
#+LATEX_HEADER: \captionsetup[lstlisting]{font={it,footnotesize},labelfont={it,footnotesize},singlelinecheck=false}

#+LATEX_HEADER: \usepackage{sclang-prettifier}

#+LATEX_HEADER: \hyphenation{Synth-Def Synth-Defs}

#+LATEX_HEADER: \usepackage{environ}
#+LATEX_HEADER: \NewEnviron{boxnote}[1][]{\bigskip\noindent\framebox[1\textwidth]{\parbox[c]{0.95\textwidth}{\textbf{Note:} \BODY}}\bigskip}

* Introduction
#+LATEX: \frenchspacing
** Overview
/Chucklib-livecode/ (/cll/ for short) is a system of extremely compact
commands extending the SuperCollider programming language. The
commands manipulate musical processes in real time to facilitate
live-coding performances. "Processes" in this sense refers to my
/chucklib/ quark, introduced in /The SuperCollider Book/.[fn:5b6ef116]

I began implementing /cll/ in August 2014, and it reached a stage
where I could begin performing with it in March 2015. The public
extensions are hosted on github.[fn:8ae1bb90]

/cll/ consists of two main parts:

1. A chucklib /process prototype/ (PR) that implements the methods
   that the musical processes need, in order to receive information
   from live-coding statements.

2. A /preprocessor/ installed into the SuperCollider interpreter. The
   preprocessor translates the /cll/ command syntax into standard
   SuperCollider code.

This document will cover the process prototype first. You need to
understand its structure in order to understand the commands.

** Acknowledgments
Thanks are due to:

- James McCartney and all the other developers who contributed to
  SuperCollider over the years. Without SuperCollider, none of this
  would exist.

- Alex McLean, for his work on the /Tidal/ live-coding language for
  music.(fn) /Tidal/ demonstration videos online were the first to
  capture my imagination about live coding, leading me in this
  direction.

- Thor Magnusson, whose /ixilang/ system provided the inspiration for
  /cll/ syntax.

* Process prototype
** Data structure
/cll/ organizes musical behavior, and musical content, hierarchically:

- Chucklib /processes/ (BP) contain any number of /phrases/. Every
  process has its own variable scope (i.e., independent
  namespace). Activity in one process does not interfere with other
  processes.
- Each /phrase/ contains multiple /parameters/. (The phrase itself is
  implemented as a [[Classes/PbindProxy][PbindProxy]], so that its contents can be changed at
  any time.)
- Each /parameter/ is defined by a pattern string, parsed and rendered
  into SuperCollider pattern syntax by the /[[Set pattern statement][Set pattern]]/ statement.
- Parameter values are defined by the /parameter map/ (=parmMap=).

# The BP also keeps a copy of the strings, for easier editing later.

/cll/ processes create two phrases by default:

- =main= :: The default phrase, which plays if the user hasn't
     specified a different phrase sequence. =main= is also the default
     phrase that /Set pattern/ acts on---thus, a user can work with
     single-bar loops using only =main=, and never specify a phrase
     ID.
- =rest= :: An empty phrase, which only occupies time.

** PR(\textbackslash abstractLiveCode)
#+begin_figure
#+name: instance1
#+caption: A simple cll process.
#+BEGIN_SRC {SuperCollider} -i
(
PR(\abstractLiveCode).chuck(BP(\beep), nil, (
   userprep: {
      ~buf = Buffer.read(
         s, Platform.resourceDir +/+ "sounds/a11wlk01.wav",
         4982, 10320
      );
      ~defaults[\bufnum] = ~buf;
      SynthDef(\buf1, { |out, bufnum, pan, amp|
         var sig = PlayBuf.ar(1, bufnum),
         eg = EnvGen.kr(
            Env.linen(0.02, BufDur.ir(bufnum) - 0.04, 0.02),
            doneAction: 2
         );
         Out.ar(out, Pan2.ar(sig, pan, amp * eg));
      }).add;
   },
   userfree: {
      ~buf.free;
   },
   defaultParm: \amp,
   parmMap: (
      amp: ($.: 0.1, $-: 0.4, $^: 0.8),
      pan: (
         $<: -0.9, $>: 0.9,
         $(: -0.4, $): 0.4,
         $-: 0
      )
   ),
   defaults: (instrument: \buf1),
   postDefaults: Pbind(
      \time, (Pkey(\dur) * 0.6 / Pfunc { ~clock.tempo }).clip(0.04, 0.2)
   )
));
)

// Use it, with cll statements:
TempoClock.tempo = 2;

/beep = "^|.. .| .- | .  ";  // "Set pattern"
/beep+;  // start it

/beep..pan = "<><><><>";

/beep-;

/beep(free);
#+END_SRC
#+end_figure

To create a /cll/ process, "chuck" =PR(\abstractLiveCode)= into a BP
("Bound Process"), with a parameter dictionary providing the
details. Parameters to include in the dictionary:

- =userprep= :: A function, called when the process is created. Use
     this function to create any resources that the process will
     require.
- =userfree= :: A function, called when the process is
     destroyed. Clean up any resources allocated in =userprep=.
- =defaultParm= :: The name of the default parameter affected by /[[Set pattern statement][Set pattern]]/
     statements. The default parameter also controls rhythm.
- =parmMap= :: A nested dictionary of parameters, their allowed
     values, and the characters that will identify these values in
     pattern strings.
- =defaults= :: An =Event= or event pattern providing default values
     for the events that the process will play.
- =postDefaults= :: (optional) An event pattern that can do further
     calculations on the parameter values.

This dictionary is not limited to these items. You may add any other
data and functions that you need, to define complex behavior in terms
of simpler functions and patterns.

In @@latex:Listing \ref{instance1}@@, =userprep= loads a buffer and
=userfree= releases it. By default, /Set pattern/ will operate on
=amp=, and =parmMap= defines three values for it (soft, medium and
loud). =parmMap= also provides some panning options. The =defaults=
dictionary specifies the SynthDef to use (it may provide other synth
defaults as well, not needed in this example), and =postDefaults=
calculates the sounding duration of each note based on rhythm.

Note the line =~defaults[\bufnum] = ~buf=: You may add values into
=defaults= as part of =userprep=. That's necessary in this case
because the buffer number is not known in advance. The only way to
supply the buffer number as a default is to read the buffer first,
and put it into the defaults dictionary only after that.

#+begin_boxnote
Clearly, the code to initialize the process in @@latex:Listing
\ref{instance1}@@ is too long to be practical to type in the middle of
a performance. For practical purposes, you should place all of the
process definitions into a separate file, which you would load once at
the beginning of a performance. See also the /[[Make statement][Make]]/ statement, which
makes it easy to instantiate the processes as needed during the
performance, reducing the overhead of initial loading. (In fact,
Chucklib was designed from the beginning to "package" complex musical
behaviors into objects that are simpler to use, once defined. /cll/ is
an even more compact layer of control on top of this, following the
same design principle: /definition/ and /performance usage/ are
different, and call for different types of code.)
#+end_boxnote

** Parameter map
The parameter map =parmMap= is easiest to write as a set of nested [[Classes/Event][Events]]:

#+BEGIN_SRC {SuperCollider} -i
parmMap: (
   parmName: (
      char: value,
      char: value,
      char: value...
   ),
   parmName: (...)
)
#+END_SRC

=parmName= keys should be Symbols. The keys of the inner dictionaries
should be characters ([[Classes/Char][Char]]), because the elements of the pattern
strings that represent "notes" are characters.

The inner dictionaries may contain two other items, optionally:

- =isPitch= :: If =true=, enables [[Pitch notation][pitch notation]] for this parameter.
- =alias= :: An alternate name for this parameter, to use in the
     pattern. For example, if the parameter should choose from a
     number of SynthDefs, it would be inconvenient to type
     =instrument= in the performance every time you need to control
     it, whereas =def= would be faster. You can do this as follows:
     #+BEGIN_SRC {SuperCollider} -i
     parmMap: (
        def: (
           alias: \instrument,
           $s: \sawtooth, $p: \pulse, $f: \fm
        )
     )

     // Then you can set the "instrument" pattern:
     /proc.phrase.def = "s";
     #+END_SRC
     Written this way, =def= in the /Set pattern/ statement will be
     converted into =instrument= in the pattern.

*** Array arguments in the parameter map
Array arguments must be enclosed in one extra array layer. That is, if
you want to send an array of three frequencies such as =[200, 300,
400]=, this must be given in the parameter map as =[ [200, 300, 400] ]=.

#+BEGIN_SRC {SuperCollider} -i
parmMap: (
   freqs: (
      $2: [[200, 300, 400]],
   ),
   parmName: (...)
)
#+END_SRC

Envelopes may be passed to arrayed Synth controls in the same way:
=[Env.perc(0.01, 0.5).asArray]=.

One other use of parameter map array is used to set disparate Event
keys using one /cll/ parameter. =Pbind= allows multiple keys to be set
at once by providing an array for a key. /cll/ supports this by using
an array for the alias!

#+BEGIN_SRC {SuperCollider} -i
parmMap: (
   filt: (
      alias: [\ffreq, \rq],
      $x: [[2000, 0.05]]
   )
)
#+END_SRC

**** TODO Discuss singleSynthPlayer vs. default

** Event processing
Every event produced by a /cll/ process goes through three stages:

1. Insert all the items from =defaults=.
2. Insert the values from the current phrase (defined by pattern strings).
3. Insert any values from =postDefaults=. This may be a =Pbind=, and
   it has access to all the values from 1 and 2 by =Pkey=.

Thus, you can use =postDefaults= to derive values from items defined
in the parameter map, or to check for invalid values.

** Phrase sequence

/cll/ "Set pattern" statements put musical information into any number
of phrases. When you play the process, it chooses the phrases one by
one using a pattern stored as =phraseSeq=. "Set pattern" has a compact
way to express phrase sequences, allowing sequences, random selection
(with or without weights) and wildcard matching. See [[Phrase selection][Phrase selection]]
for details.

This design supports musical contrast. The performer can create
divergent materials under different phrase identifiers. Then, during
the performance, she can change the phrase-selection pattern to switch
materials on the fly. Sudden textural changes require changing many
phrase-selection pattern at once. For this, [[Register]] commands can save
sequences of statements to reuse quickly and easily.

** Importing the cll API into another process prototype		   :noexport:

* Livecoding statement reference
** Statement types
/cll/ statements begin with a slash: =/=. Statements may be separated
by semicolons and submitted as a batch.

#+BEGIN_SRC {SuperCollider} -i
// run one at a time
/kick.fotf = "----";
/snare.bt24 = " - -";

// or as a batch
/kick.fotf = "----"; /snare.bt24 = " - -";
#+END_SRC

/cll/ supports the following statements, in order of importance.

#+ATTR_LATEX: :align |l|p{0.35\textwidth}|p{0.35\textwidth}|
|--------------+-----------------------------------------------------------------+------------------------------------------|
| *Type*       | *Function*                                                      | *Syntax outline*                         |
|--------------+-----------------------------------------------------------------+------------------------------------------|
| Set pattern  | Add new musical information into a process                      | \texttt{/proc.phrase.parm = "data"}      |
|--------------+-----------------------------------------------------------------+------------------------------------------|
| Start/stop   | Start or stop one or more procesess                             | \texttt{/proc/proc/proc+} or \texttt{-}  |
|--------------+-----------------------------------------------------------------+------------------------------------------|
| Generator    | Create several randomized patterns at once                      | \texttt{/proc.phrase.parm *n +ki "base"} |
|--------------+-----------------------------------------------------------------+------------------------------------------|
| Make         | Instantiate a process or voicer                                 | \texttt{/make(factory/factory)}          |
|--------------+-----------------------------------------------------------------+------------------------------------------|
| Func call    | Call a function in chucklib's \texttt{Func} collection          | \texttt{/funcname.(arguments)}           |
|--------------+-----------------------------------------------------------------+------------------------------------------|
| Passthrough  | Pass a method call to a \texttt{BP}                             | \texttt{/proc(method and arguments)}     |
|--------------+-----------------------------------------------------------------+------------------------------------------|
| Chuck        | Pass a chuck \texttt{=>} operation to a BP                      | \texttt{/proc => target }                |
|--------------+-----------------------------------------------------------------+------------------------------------------|
| Copy         | Copy a phrase or phrase set into a different name               | \texttt{/proc.phrase*n -> new}           |
|--------------+-----------------------------------------------------------------+------------------------------------------|
| Transfer     | Like "Copy," but also uses the new phrase for play              | \texttt{/proc.phrase*n ->> new}          |
|--------------+-----------------------------------------------------------------+------------------------------------------|
| Show pattern | Copies a phrase pattern's string into the document, for editing | \texttt{/proc.phrase.parm}               |
|--------------+-----------------------------------------------------------------+------------------------------------------|

*** types							   :noexport:
    - [X] \clMake -> "^ *make\\(.*\\)",
    - [X] \clFuncCall -> "^ *`id\\.\\(.*\\)",
    - [X] \clPassThru -> "^ *`id\\(.*\\)",
    - [X] \clChuck -> "^ *`id *=>.*",
    - [X] \clPatternSet -> "^ *`id(\\.|`id|`id\\*[0-9]+)* = .*",
    - [X] \clGenerator -> "^ *`id(\\.|`id)* \\*.*",
    - [X] \clXferPattern -> "^ *`id(\\.`id)?(\\*`int)? ->>",  // harder match should come first
    - [X] \clCopyPattern -> "^ *`id(\\.`id)?(\\*`int)? ->",
    - [X] \clStartStop -> "^([/`spc]*`id)+[`spc]*[+-]",
    - [X] \clPatternToDoc -> "^ *`id(\\.|`id)*[`spc]*$"

** Set pattern statement
/Set pattern/ is the primary interface for composing or improvising
musical materials. As such, it's the most complicated of all the
commands.

This statement type subdivides into two functions: phrase /definition/
and phrase /selection/.

*** Phrase definition
Most "Set pattern" statements follow this format:

#+name: setpatternSyntax
#+caption: Syntax template for the Set pattern statement.
#+BEGIN_SRC {SuperCollider} -i
/proc.phrase.parm = quant"string";
#+END_SRC

Syntax elements:

- =proc= :: The BP's name.
- =phrase= :: (optional) The phrase name. If not given, =main= is assumed.
- =parm= :: (optional) The parameter name. The BP must define a
     default parameter name, to use if this is omitted.
- =quant= :: (optional) Determines the phrase's length, in beats.
  - A number, or numeric math expression, specifies the number of beats.
  - =+= followed by a number indicates "additive rhythm." The number
    is taken as a base note value. All items in the string are assumed
    to occupy this note value, making it easier to create
    fractional-length phrases. (If only =+= is given, the BP may
    specify =division=; otherwise 0.25 is the default.)
  - If =quant= is omitted entirely, the BP's =beatsPerBar= is
    used. Usually this is the =beatsPerBar= of the BP's assigned
    clock.
- =string= :: Specifies parameter values and rhythms.

#+BEGIN_boxnote
Both the phrase and parameter names are optional. That allows
the following syntactic combinations:

#+ATTR_LATEX: :align |l|l|
|-------------------------------+--------------------------------------|
| *Syntax*                      | *Behavior*                           |
|-------------------------------+--------------------------------------|
| \texttt{/proc = "string"}     | Set phrase "main," default parameter |
|-------------------------------+--------------------------------------|
| \texttt{/proc.x = "string"}   | Set phrase "x," default parameter    |
|-------------------------------+--------------------------------------|
| \texttt{/proc.x.y = "string"} | Set phrase "x," parameter "y"        |
|-------------------------------+--------------------------------------|
| \texttt{/proc..y = "string"}  | Set phrase "main," parameter "y"     |
|-------------------------------+--------------------------------------|

Of these, the last looks somewhat surprising. It makes sense if you
think of the double-dot as a delimiter for an empty phrase name.
#+END_boxnote

*** Pattern string syntax
Pattern strings place values at time points within the bar. The values
come from the parameter map. Timing comes from the items' positions
within the string, based on the general idea of equal division of the
bar.

Two characters are reserved: a space is a timing placeholder, and
a vertical bar, \textbar, is a divider.

If the string has no dividers, then the items within it (including
placeholders) are equally spaced throughout the bar. This holds true
even if it's a nonstandard division: #4 has seven characters in the
string, producing a septuplet.

If there are dividers, the measure's duration will be divided first:
$n$ dividers produce $n+1$ units. Then, within each division, items
will be equally spaced. The spacing is independent for each
division. For example, in #6 below, the first division contains one
item, but the second contains two. For all the divisions to have the
same duration, then, =-= in the second division should be half as long
as in the first.

#+name: rhythmNotation1
#+caption: Some examples of cll rhythmic notation, with and without dividers.
[[./manual-supporting/rhythmic-notation-crop.pdf]]

#+BEGIN_boxnote
It isn't exactly right to think of a space as a "rest."
@@latex:\texttt{"- - "}@@ is not really two quarter notes separated by
quarter rests; it's actually two half notes! If you need to silence
notes explicitly, then you should define an item in the parameter map
whose value is a =Rest= object.
#+END_boxnote

**** TODO Set pattern examples

#+name: setpatternExamples
#+caption: Set pattern examples.
#+BEGIN_SRC {SuperCollider} -i
/kick = "----";  // Set kick's 'main' phrase to four quarter notes

/kick
#+END_SRC

*** Timing of multiple parameters
Each parameter can have its own timing, but a =Pbind= can play with
only one rhythm, raising a potential conflict.

The =Pbind= rhythm is determined by the pattern string for the
=defaultParm= declared in the process. When you set the =defaultParm=
to a pattern, the rhythm defined in that string is assigned to the
=\dur= key, where it drives the process's timing. Other parameters
encode timing into a =Pstep=, to preserve the values' positions within
the bar. Think of these as "sample-and-hold" values, where the control
value /changes/ at times given by its own rhythm, but is /sampled/
only at the times given by the =defaultParm= rhythm.

For example, here, the default parameter's rhythm is two half
notes. At the same time, a filter parameter changes on beats 1, 2
and 4. The process will play two events, on beats 1 and 3. On beat 1,
the filter will use its =a= value; on beat 3, it will use the most
recent value, which is =b=. /The filter will not change on beat 2/,
because there is no event occurring on that beat!

What about =c=? There is no event coming on or after beat 4, so =c=
will be ignored in this case. But, if you add another note late in the
bar, then it will pick up =c=, without any other change needed.

#+BEGIN_SRC {SuperCollider} -i
/x = "--";
/x.filt = "ab c";  // "c" is not heard

/x = "-|-  -";  // now "c" is heard on beat 4.5
#+END_SRC

*** Pitch notation
#+begin_figure
#+name: pitchSet1
#+caption: A retro acid-house bassline.
#+BEGIN_SRC {SuperCollider} -i
(
SynthDef(\sqrbass, { |out, freq = 110, gate = 1,
   freqMul = 1.006, amp = 0.1,
   filtMul = 3, filtDecay = 0.12, ffreq = 2000, rq = 0.1,
   lagTime = 0.1|
   var sig = Mix(
      Pulse.ar(
         Lag.kr(freq, lagTime) * [1, freqMul],
         0.5
      )
   ) * amp,
   filtEg = EnvGen.kr(
      Env([filtMul, filtMul, 1], [0.005, filtDecay], \exp),
      gate
   ),
   ampEg = EnvGen.kr(
      Env.adsr(0.01, 0.08, 0.5, 0.1),
      gate, doneAction: 2
   );
   sig = RLPF.ar(sig, (ffreq * filtEg).clip(20, 20000), rq);
   Out.ar(out, (sig * ampEg).dup);
}).add;

BP(\acid).free;
PR(\abstractLiveCode).chuck(BP(\acid), nil, (
   event: (eventKey: \default),
   alwaysReset: true,
   defaultParm: \degree,
   parmMap: (
      degree: (isPitch: true),
   ),
   defaults: (
      ffreq: 300, filtMul: 8, rq: 0.2,
      octave: 3, root: 6, scale: Scale.locrian.semitones
   ),
   postDefaults: PmonoArtic(\sqrbass,
      \dummy, 1
   )
));

TempoClock.tempo = 132/60;
)

/acid = "1_  1.|5~3_9.4.|7.2~4_5'.|5_8~2_4.";

/acid+;
/acid-;
#+END_SRC
#+end_figure

If a parameter's map specifies =isPitch: true=, then it does not need
to specify any other values and the following rules apply:

- Scale degrees are given by decimal digits, where 1 is the tonic and
  0 is the interval of a tenth above that (following the number row on
  the keyboard).[fn:84cfcfa1]

- @@latex:\texttt{+}@@ and @@latex:\texttt{-}@@ raise and lower the pitch by a semitone.

- @@latex:\texttt{'}@@ and @@latex:\texttt{,}@@ displace the pitch by
  an octave up or down, respectively. Multiple apostrophes or commas
  displace by multiple octaves. (This syntax is borrowed from
  LilyPond.)[fn:0fe09d88]

- @@latex:\texttt{.}@@ indicates a staccato note.

- @@latex:\texttt{\textunderscore}@@ indicates legato (sustain
  duration slightly shorter than note duration).

- @@latex:\texttt{\textasciitilde}@@ slurs this note into the next note.

#+BEGIN_boxnote
Items in pitch sequences may include more than one character:
 =3= is one note, as is =6+,~=.
#+END_boxnote

@@latex:Listing \ref{pitchSet1}@@ illustrates the kind of articulation
that is possible with this notation, using a 90s-throwback acid-style
bassline. Though the sound is not as cool as a real TB303, careful use
of slurs and staccatos mimics the feel of the venerable old
machine.[fn:be0c1420] A further refinement would be to add values for
filter frequency and =filtMul= into the parameter map.

*** Phrase selection
Statements to set the phrase sequence follow a different syntax:

#+BEGIN_SRC {SuperCollider} -i
/proc = (group...);
#+END_SRC

=group= can consist of any of the following elements:

- Phrase ID :: The name of any phrase that's already defined, or a
     regular expression in single quote marks. If more than one
     existing phrase matches the regular expression, one of the
     matches will be chosen at random; e.g., to choose randomly among
     phrases beginning with =x=, write @@latex:\texttt{'\textasciicircum{}x'}@@.
- Name sequence :: Two or more of /any/ of these items, separated by
     dots and enclosed in parentheses: =(a0.a1.a2)=. These will be
     enclosed in =Pseq=.
- Random selection :: Two or more of any of these items, separated by
     vertical bars (\textbar) and enclosed in parentheses:
     =(a0|a1|a2)=. These will be enclosed in =Prand=. /One/ will be
     chosen before advancing to the next ID.
- Phrase group :: A name, followed by two asterisks and a number of
     bars in the phrase group. If a four-bar phrase is stored as =a0=,
     =a1=, =a2=, and =a3=, you can write it simply as =a**4=. The
     preprocessor will expand this to regular expression matches, as
     if you had written =('^a0'.'^a1'.'^a2'.'^a3')=. The use of
     regular expression matching here is to make it easier to have
     slight variations on the bars within the phrase group, while
     keeping the same musical shape.

Any of these items may optionally attach a number of repeats =*n=:
=(a*3.b)= translates to =Pseq([Pn(\a, 3), \b], inf)=, and =(a*3|b)= to
=Prand([Pn(\a, 3), \b], inf)=.

Items in a random selection may also attach a weight =%w=, which must
be given as an integer: =(a%6|b%4)= has a 60% chance of choosing =a=
and a 40% chance of =b=. If no weight is given, the default
is 1. Weights are ignored for sequences (separated by dots).

Groups may be nested, producing complex structures compactly. For
example, to have an 80% chance of =a= for four bars, then an 80%
chance of =b= for two bars, you would write:

#+BEGIN_SRC {SuperCollider} -i
((a%4|b)*4.(a|b%4)*2)
#+END_SRC

You may also include both =.= and =|= in a single set of
parentheses. The dot (for sequence) takes precedence: =(a.b|c)=
evaluates as =((a.b)|c)=.

** Start/stop statement
** Generator statement
** Make statement
** Func call statement
** Passthrough statement
** Chuck statement
** Copy or transfer statement
** Show pattern statement
** Helper functions

* Extending cll
** Preprocessor architecture
* Footnotes

[fn:84cfcfa1] In SuperCollider pattern terms, =1= translates into degree 0.

[fn:0fe09d88] Currently a diatonic scale (7 degrees) is assumed.

[fn:5b6ef116] Harkins, H. James. (2011). "Composition for Live
Performance with dewdrop\textunderscore lib and chucklib." In Wilson,
S. / Cottle, D. / Collins N. [eds.] /The SuperCollider
Book/. Cambridge, Mass.: MIT Press. pp. 589--612.

[fn:8ae1bb90] http://github.com/jamshark70/chucklib-livecode

[fn:be0c1420] Note the trick to get monophonic synthesis. Assigning a
=PmonoArtic= into =postDefaults= effectively turns the entire
event-producing chain into a =PmonoArtic=---even if it adds no
musically useful information into the resulting events. /Caveat/: If
you will have any notes slur across the barline, make sure to include
=alwaysReset: true= in the BP parameter dictionary.
